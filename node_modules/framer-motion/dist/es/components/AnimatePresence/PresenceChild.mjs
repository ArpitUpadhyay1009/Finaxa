<<<<<<< HEAD
=======
"use client";
import { jsx } from 'react/jsx-runtime';
>>>>>>> 3c08b929f5a458570a719f4b5eccee16e2fc4c1d
import * as React from 'react';
import { useId, useMemo } from 'react';
import { PresenceContext } from '../../context/PresenceContext.mjs';
import { useConstant } from '../../utils/use-constant.mjs';
import { PopChild } from './PopChild.mjs';

<<<<<<< HEAD
const PresenceChild = ({ children, initial, isPresent, onExitComplete, custom, presenceAffectsLayout, mode, }) => {
    const presenceChildren = useConstant(newChildrenMap);
    const id = useId();
    const context = useMemo(() => ({
        id,
        initial,
        isPresent,
        custom,
        onExitComplete: (childId) => {
            presenceChildren.set(childId, true);
            for (const isComplete of presenceChildren.values()) {
                if (!isComplete)
                    return; // can stop searching when any is incomplete
            }
            onExitComplete && onExitComplete();
        },
        register: (childId) => {
            presenceChildren.set(childId, false);
            return () => presenceChildren.delete(childId);
        },
    }), 
=======
const PresenceChild = ({ children, initial, isPresent, onExitComplete, custom, presenceAffectsLayout, mode, anchorX, root }) => {
    const presenceChildren = useConstant(newChildrenMap);
    const id = useId();
    let isReusedContext = true;
    let context = useMemo(() => {
        isReusedContext = false;
        return {
            id,
            initial,
            isPresent,
            custom,
            onExitComplete: (childId) => {
                presenceChildren.set(childId, true);
                for (const isComplete of presenceChildren.values()) {
                    if (!isComplete)
                        return; // can stop searching when any is incomplete
                }
                onExitComplete && onExitComplete();
            },
            register: (childId) => {
                presenceChildren.set(childId, false);
                return () => presenceChildren.delete(childId);
            },
        };
    }, [isPresent, presenceChildren, onExitComplete]);
>>>>>>> 3c08b929f5a458570a719f4b5eccee16e2fc4c1d
    /**
     * If the presence of a child affects the layout of the components around it,
     * we want to make a new context value to ensure they get re-rendered
     * so they can detect that layout change.
     */
<<<<<<< HEAD
    presenceAffectsLayout ? undefined : [isPresent]);
=======
    if (presenceAffectsLayout && isReusedContext) {
        context = { ...context };
    }
>>>>>>> 3c08b929f5a458570a719f4b5eccee16e2fc4c1d
    useMemo(() => {
        presenceChildren.forEach((_, key) => presenceChildren.set(key, false));
    }, [isPresent]);
    /**
     * If there's no `motion` components to fire exit animations, we want to remove this
     * component immediately.
     */
    React.useEffect(() => {
        !isPresent &&
            !presenceChildren.size &&
            onExitComplete &&
            onExitComplete();
    }, [isPresent]);
    if (mode === "popLayout") {
<<<<<<< HEAD
        children = React.createElement(PopChild, { isPresent: isPresent }, children);
    }
    return (React.createElement(PresenceContext.Provider, { value: context }, children));
=======
        children = (jsx(PopChild, { isPresent: isPresent, anchorX: anchorX, root: root, children: children }));
    }
    return (jsx(PresenceContext.Provider, { value: context, children: children }));
>>>>>>> 3c08b929f5a458570a719f4b5eccee16e2fc4c1d
};
function newChildrenMap() {
    return new Map();
}

export { PresenceChild };
