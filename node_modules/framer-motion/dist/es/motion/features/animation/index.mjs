import { isAnimationControls } from '../../../animation/utils/is-animation-controls.mjs';
import { createAnimationState } from '../../../render/utils/animation-state.mjs';
import { Feature } from '../Feature.mjs';

class AnimationFeature extends Feature {
    /**
     * We dynamically generate the AnimationState manager as it contains a reference
     * to the underlying animation library. We only want to load that if we load this,
     * so people can optionally code split it out using the `m` component.
     */
    constructor(node) {
        super(node);
        node.animationState || (node.animationState = createAnimationState(node));
    }
    updateAnimationControlsSubscription() {
        const { animate } = this.node.getProps();
<<<<<<< HEAD
        this.unmount();
        if (isAnimationControls(animate)) {
            this.unmount = animate.subscribe(this.node);
=======
        if (isAnimationControls(animate)) {
            this.unmountControls = animate.subscribe(this.node);
>>>>>>> 3c08b929f5a458570a719f4b5eccee16e2fc4c1d
        }
    }
    /**
     * Subscribe any provided AnimationControls to the component's VisualElement
     */
    mount() {
        this.updateAnimationControlsSubscription();
    }
    update() {
        const { animate } = this.node.getProps();
        const { animate: prevAnimate } = this.node.prevProps || {};
        if (animate !== prevAnimate) {
            this.updateAnimationControlsSubscription();
        }
    }
<<<<<<< HEAD
    unmount() { }
=======
    unmount() {
        this.node.animationState.reset();
        this.unmountControls?.();
    }
>>>>>>> 3c08b929f5a458570a719f4b5eccee16e2fc4c1d
}

export { AnimationFeature };
